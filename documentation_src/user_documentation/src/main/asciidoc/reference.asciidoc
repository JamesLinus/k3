== Language Reference

=== Basic

==== Creating an aspect on a class
1. Add the annotation _**Aspect**_ on the class corresponding to the aspect
2. Specify the class to augment using the annotation parameter **className**
3. Update the imported packages using **ctrl+shift+o**


Let's start from a classic class _Foo_ that we will extend with aspects.
```xtend
package mypackage
class Foo{
    def void hello(){
        println("Hello from Foo")
    }
}
```

now we will add a aspect on it.

```k3
package mypackage

import fr.inria.triskell.k3.Aspect

import mypackage.Foo

@Aspect(className=Foo)
class FooAspect {
    def void display (){
         prinln("I am FooAspect")
    }
}
```

In an aspect you can use the attributes and operations of both the augmented class and the aspect itself.

In aspects **the keyword** "_**this**_" **must not be used**.
Instead, the keyword "**_self**" must be used.

```k3
@Aspect(className=BaseClass)
class BaseClassAspect {
    int anInteger = 1

    def void display (){
         // The keyword _self must be used to refer to attributes and operations of the class and aspect.
         _self.anInteger = 2
         _self.hello()
    }
}
```

Despite it should be legal, due to a bug in xtend, we **do not** recommand the following syntax:
```k3
@Aspect(className=typeof(OtherClass))
```
It may raise strange scope issue, especially in case of aspects defined in several packages.

==== Using aspect from another k3/xTend program

To use the aspect, you need to import the correct classes and indicates to xTend thant some additionnal feautres can come from the aspect.

This is done using the special import **import static extension** which enable the use of the additions declared in the aspect.


```k3
package mypackage

import mypackage.Foo
import mypackage.FooAspect

import static extension mypackage.FooAspect.*

class Main {
    def static void main(){
      val Foo f1 = new Foo   
      f1.display()
    }
}

```

TODO: ajouter dans un callout To use the operations and attributes added in a class, you have to import the aspect:
_import static extension myPkg.AspectName.*_


===== Disambiguisation

If several operations or attributes have similar names, xTend may not find the expected feature.
In that case you need to disambiguise the call by accessing the underlying helper class.

_* TODO *_ show an example of direct, non ambiguious call using the underlying helper class.

[Tip]
----
Be careful when cleaning unused imports while your programs isn't complete (for example using **ctrl+shift+o**) because it will also removed unused static extension and will disable the code completion (**ctrl+space**) for the features of these aspects.
----

==== Extending an aspect (classic inheritance)

Extending an aspect can be performed as in Xtend.

Let's consider the class _Bar_ that inherits from _Foo_


Let's start from a classic class _Foo_ that we will extend with aspects.
```xtend
package mypackage
class Bar extends Foo{
    def void hello(){
        println("Hello from Bar")
    }
}
```


However, as for Java, an aspect can directly inherit from only one aspect!


```k3
package mypackage

import fr.inria.triskell.k3.Aspect
import fr.inria.triskell.k3.OverrideAspectMethod

import mypackage.Foo
import mypackage.Bar

import static extension mypackage.FooAspect.*

@Aspect(className=Bar)
class BarAspect extends FooAspect {
    // Annotation to tag the operation as an operation overloading a super operation
    @OverrideAspectMethod
    def void display(){
      println("I am BarAspect")
    }
}
```

==== Calling a super operation
A call to a super operation can be done by writing **super_** followed by the name of the operation. Do not forget to use **_self** to handle elements of the class or aspect.

```k3
@Aspect(className=MyClass)
class MyClassAspect extends OtherClassAspect {
    @OverrideAspectMethod
    def void display(){
       _self.super_display()
       prinln("I am MyClassAspect")
    }
}
```


=== Advanced

==== Extending an aspect (multi inheritance)
Even if Java allows only one inheritance via _extends_.
When using EMF, it is legal to inherit from several class. The underlying framework will take care to implement a pattern using Interfaces.

Our aspects must alos be able to deal  with that situation.

For this K3, offers the ??? annotation