/*
* generated by Xtext
*/
package insa.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class LegoGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProgramUnit");
		private final Assignment cBlockAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBlockExpressionParserRuleCall_0 = (RuleCall)cBlockAssignment.eContents().get(0);
		
		//ProgramUnit returns robot::ProgramUnit:
		//	block+=Expression*;
		public ParserRule getRule() { return rule; }

		//block+=Expression*
		public Assignment getBlockAssignment() { return cBlockAssignment; }

		//Expression
		public RuleCall getBlockExpressionParserRuleCall_0() { return cBlockExpressionParserRuleCall_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNegExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAndExpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfBlockParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCommandParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Expression returns FlotCtrl::Expression:
		//	WhileLoop | NegExp | AndExp | IfBlock | Command;
		public ParserRule getRule() { return rule; }

		//WhileLoop | NegExp | AndExp | IfBlock | Command
		public Alternatives getAlternatives() { return cAlternatives; }

		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_0() { return cWhileLoopParserRuleCall_0; }

		//NegExp
		public RuleCall getNegExpParserRuleCall_1() { return cNegExpParserRuleCall_1; }

		//AndExp
		public RuleCall getAndExpParserRuleCall_2() { return cAndExpParserRuleCall_2; }

		//IfBlock
		public RuleCall getIfBlockParserRuleCall_3() { return cIfBlockParserRuleCall_3; }

		//Command
		public RuleCall getCommandParserRuleCall_4() { return cCommandParserRuleCall_4; }
	}

	public class BoolExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNegExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAndExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHasTurnedCmdParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cObstacleCmdParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//BoolExp returns FlotCtrl::BoolExp:
		//	NegExp | AndExp | HasTurnedCmd | ObstacleCmd;
		public ParserRule getRule() { return rule; }

		//NegExp | AndExp | HasTurnedCmd | ObstacleCmd
		public Alternatives getAlternatives() { return cAlternatives; }

		//NegExp
		public RuleCall getNegExpParserRuleCall_0() { return cNegExpParserRuleCall_0; }

		//AndExp
		public RuleCall getAndExpParserRuleCall_1() { return cAndExpParserRuleCall_1; }

		//HasTurnedCmd
		public RuleCall getHasTurnedCmdParserRuleCall_2() { return cHasTurnedCmdParserRuleCall_2; }

		//ObstacleCmd
		public RuleCall getObstacleCmdParserRuleCall_3() { return cObstacleCmdParserRuleCall_3; }
	}

	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLoopCondAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLoopCondBoolExpParserRuleCall_1_0 = (RuleCall)cLoopCondAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBlockExpressionParserRuleCall_3_0 = (RuleCall)cBlockAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//WhileLoop returns FlotCtrl::WhileLoop:
		//	"while" loopCond=BoolExp "do" block+=Expression* "end";
		public ParserRule getRule() { return rule; }

		//"while" loopCond=BoolExp "do" block+=Expression* "end"
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//loopCond=BoolExp
		public Assignment getLoopCondAssignment_1() { return cLoopCondAssignment_1; }

		//BoolExp
		public RuleCall getLoopCondBoolExpParserRuleCall_1_0() { return cLoopCondBoolExpParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//block+=Expression*
		public Assignment getBlockAssignment_3() { return cBlockAssignment_3; }

		//Expression
		public RuleCall getBlockExpressionParserRuleCall_3_0() { return cBlockExpressionParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}

	public class NegExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpBoolExpParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		
		//NegExp returns FlotCtrl::NegExp:
		//	"not" exp=BoolExp;
		public ParserRule getRule() { return rule; }

		//"not" exp=BoolExp
		public Group getGroup() { return cGroup; }

		//"not"
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }

		//exp=BoolExp
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }

		//BoolExp
		public RuleCall getExpBoolExpParserRuleCall_1_0() { return cExpBoolExpParserRuleCall_1_0; }
	}

	public class AndExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftExpBoolExpParserRuleCall_1_0 = (RuleCall)cLeftExpAssignment_1.eContents().get(0);
		private final Assignment cRightExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightExpBoolExpParserRuleCall_2_0 = (RuleCall)cRightExpAssignment_2.eContents().get(0);
		
		//AndExp returns FlotCtrl::AndExp:
		//	"and" leftExp=BoolExp rightExp=BoolExp;
		public ParserRule getRule() { return rule; }

		//"and" leftExp=BoolExp rightExp=BoolExp
		public Group getGroup() { return cGroup; }

		//"and"
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }

		//leftExp=BoolExp
		public Assignment getLeftExpAssignment_1() { return cLeftExpAssignment_1; }

		//BoolExp
		public RuleCall getLeftExpBoolExpParserRuleCall_1_0() { return cLeftExpBoolExpParserRuleCall_1_0; }

		//rightExp=BoolExp
		public Assignment getRightExpAssignment_2() { return cRightExpAssignment_2; }

		//BoolExp
		public RuleCall getRightExpBoolExpParserRuleCall_2_0() { return cRightExpBoolExpParserRuleCall_2_0; }
	}

	public class IfBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionBoolExpParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenBlockExpressionParserRuleCall_3_0 = (RuleCall)cThenBlockAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cElseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cElseBlockAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cElseBlockExpressionParserRuleCall_4_1_0 = (RuleCall)cElseBlockAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IfBlock returns FlotCtrl::IfBlock:
		//	"if" condition=BoolExp "then" thenBlock+=Expression* ("else" elseBlock+=Expression*)? "end";
		public ParserRule getRule() { return rule; }

		//"if" condition=BoolExp "then" thenBlock+=Expression* ("else" elseBlock+=Expression*)? "end"
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=BoolExp
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//BoolExp
		public RuleCall getConditionBoolExpParserRuleCall_1_0() { return cConditionBoolExpParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//thenBlock+=Expression*
		public Assignment getThenBlockAssignment_3() { return cThenBlockAssignment_3; }

		//Expression
		public RuleCall getThenBlockExpressionParserRuleCall_3_0() { return cThenBlockExpressionParserRuleCall_3_0; }

		//("else" elseBlock+=Expression*)?
		public Group getGroup_4() { return cGroup_4; }

		//"else"
		public Keyword getElseKeyword_4_0() { return cElseKeyword_4_0; }

		//elseBlock+=Expression*
		public Assignment getElseBlockAssignment_4_1() { return cElseBlockAssignment_4_1; }

		//Expression
		public RuleCall getElseBlockExpressionParserRuleCall_4_1_0() { return cElseBlockExpressionParserRuleCall_4_1_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}

	public class CommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Command");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMoveCmdParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrintCmdParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSetTurnAngleCmdParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStopEngineCmdParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStopProgramCmdParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTurnCmdParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cHasTurnedCmdParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cObstacleCmdParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//Command returns robot::Command:
		//	MoveCmd | PrintCmd | SetTurnAngleCmd | StopEngineCmd | StopProgramCmd | TurnCmd | HasTurnedCmd | ObstacleCmd;
		public ParserRule getRule() { return rule; }

		//MoveCmd | PrintCmd | SetTurnAngleCmd | StopEngineCmd | StopProgramCmd | TurnCmd | HasTurnedCmd | ObstacleCmd
		public Alternatives getAlternatives() { return cAlternatives; }

		//MoveCmd
		public RuleCall getMoveCmdParserRuleCall_0() { return cMoveCmdParserRuleCall_0; }

		//PrintCmd
		public RuleCall getPrintCmdParserRuleCall_1() { return cPrintCmdParserRuleCall_1; }

		//SetTurnAngleCmd
		public RuleCall getSetTurnAngleCmdParserRuleCall_2() { return cSetTurnAngleCmdParserRuleCall_2; }

		//StopEngineCmd
		public RuleCall getStopEngineCmdParserRuleCall_3() { return cStopEngineCmdParserRuleCall_3; }

		//StopProgramCmd
		public RuleCall getStopProgramCmdParserRuleCall_4() { return cStopProgramCmdParserRuleCall_4; }

		//TurnCmd
		public RuleCall getTurnCmdParserRuleCall_5() { return cTurnCmdParserRuleCall_5; }

		//HasTurnedCmd
		public RuleCall getHasTurnedCmdParserRuleCall_6() { return cHasTurnedCmdParserRuleCall_6; }

		//ObstacleCmd
		public RuleCall getObstacleCmdParserRuleCall_7() { return cObstacleCmdParserRuleCall_7; }
	}

	public class BipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bip");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBipKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cDurationKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDurationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDurationINTTerminalRuleCall_4_0 = (RuleCall)cDurationAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cPowerKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cPowerAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cPowerDOUBLETerminalRuleCall_8_0 = (RuleCall)cPowerAssignment_8.eContents().get(0);
		private final Keyword cCommaKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cRepeatKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cEqualsSignKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Assignment cRepetAssignment_12 = (Assignment)cGroup.eContents().get(12);
		private final RuleCall cRepetBOOLEAN_LITERALParserRuleCall_12_0 = (RuleCall)cRepetAssignment_12.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_13 = (Keyword)cGroup.eContents().get(13);
		
		//Bip returns robot::Bip:
		//	"bip" "(" "duration" "=" duration=INT "," "power" "=" power=DOUBLE "," "repeat" "=" repet=BOOLEAN_LITERAL ")";
		public ParserRule getRule() { return rule; }

		//"bip" "(" "duration" "=" duration=INT "," "power" "=" power=DOUBLE "," "repeat" "=" repet=BOOLEAN_LITERAL ")"
		public Group getGroup() { return cGroup; }

		//"bip"
		public Keyword getBipKeyword_0() { return cBipKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"duration"
		public Keyword getDurationKeyword_2() { return cDurationKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//duration=INT
		public Assignment getDurationAssignment_4() { return cDurationAssignment_4; }

		//INT
		public RuleCall getDurationINTTerminalRuleCall_4_0() { return cDurationINTTerminalRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//"power"
		public Keyword getPowerKeyword_6() { return cPowerKeyword_6; }

		//"="
		public Keyword getEqualsSignKeyword_7() { return cEqualsSignKeyword_7; }

		//power=DOUBLE
		public Assignment getPowerAssignment_8() { return cPowerAssignment_8; }

		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_8_0() { return cPowerDOUBLETerminalRuleCall_8_0; }

		//","
		public Keyword getCommaKeyword_9() { return cCommaKeyword_9; }

		//"repeat"
		public Keyword getRepeatKeyword_10() { return cRepeatKeyword_10; }

		//"="
		public Keyword getEqualsSignKeyword_11() { return cEqualsSignKeyword_11; }

		//repet=BOOLEAN_LITERAL
		public Assignment getRepetAssignment_12() { return cRepetAssignment_12; }

		//BOOLEAN_LITERAL
		public RuleCall getRepetBOOLEAN_LITERALParserRuleCall_12_0() { return cRepetBOOLEAN_LITERALParserRuleCall_12_0; }

		//")"
		public Keyword getRightParenthesisKeyword_13() { return cRightParenthesisKeyword_13; }
	}

	public class HasTurnedCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasTurnedCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHasTurnedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAngleKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAngleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAngleDOUBLETerminalRuleCall_4_0 = (RuleCall)cAngleAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//HasTurnedCmd returns robot::HasTurnedCmd:
		//	"hasTurned" "(" "angle" "=" angle=DOUBLE ")";
		public ParserRule getRule() { return rule; }

		//"hasTurned" "(" "angle" "=" angle=DOUBLE ")"
		public Group getGroup() { return cGroup; }

		//"hasTurned"
		public Keyword getHasTurnedKeyword_0() { return cHasTurnedKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"angle"
		public Keyword getAngleKeyword_2() { return cAngleKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//angle=DOUBLE
		public Assignment getAngleAssignment_4() { return cAngleAssignment_4; }

		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_4_0() { return cAngleDOUBLETerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class MoveCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MoveCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMoveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPowerKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPowerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPowerDOUBLETerminalRuleCall_4_0 = (RuleCall)cPowerAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MoveCmd returns robot::MoveCmd:
		//	"move" "(" "power" "=" power=DOUBLE ")";
		public ParserRule getRule() { return rule; }

		//"move" "(" "power" "=" power=DOUBLE ")"
		public Group getGroup() { return cGroup; }

		//"move"
		public Keyword getMoveKeyword_0() { return cMoveKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"power"
		public Keyword getPowerKeyword_2() { return cPowerKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//power=DOUBLE
		public Assignment getPowerAssignment_4() { return cPowerAssignment_4; }

		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_4_0() { return cPowerDOUBLETerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class PrintCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrintCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDisplayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cMsgKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMsgAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMsgSTRINGTerminalRuleCall_4_0 = (RuleCall)cMsgAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cDurationKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cDurationAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cDurationINTTerminalRuleCall_8_0 = (RuleCall)cDurationAssignment_8.eContents().get(0);
		private final Keyword cCommaKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cLineKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cEqualsSignKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Assignment cLineAssignment_12 = (Assignment)cGroup.eContents().get(12);
		private final RuleCall cLineINTTerminalRuleCall_12_0 = (RuleCall)cLineAssignment_12.eContents().get(0);
		private final Keyword cCommaKeyword_13 = (Keyword)cGroup.eContents().get(13);
		private final Keyword cColKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cEqualsSignKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final Assignment cColAssignment_16 = (Assignment)cGroup.eContents().get(16);
		private final RuleCall cColINTTerminalRuleCall_16_0 = (RuleCall)cColAssignment_16.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_17 = (Keyword)cGroup.eContents().get(17);
		
		//PrintCmd returns robot::PrintCmd:
		//	"display" "(" "msg" "=" msg=STRING "," "duration" "=" duration=INT "," "line" "=" line=INT "," "col" "=" col=INT ")";
		public ParserRule getRule() { return rule; }

		//"display" "(" "msg" "=" msg=STRING "," "duration" "=" duration=INT "," "line" "=" line=INT "," "col" "=" col=INT ")"
		public Group getGroup() { return cGroup; }

		//"display"
		public Keyword getDisplayKeyword_0() { return cDisplayKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"msg"
		public Keyword getMsgKeyword_2() { return cMsgKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//msg=STRING
		public Assignment getMsgAssignment_4() { return cMsgAssignment_4; }

		//STRING
		public RuleCall getMsgSTRINGTerminalRuleCall_4_0() { return cMsgSTRINGTerminalRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//"duration"
		public Keyword getDurationKeyword_6() { return cDurationKeyword_6; }

		//"="
		public Keyword getEqualsSignKeyword_7() { return cEqualsSignKeyword_7; }

		//duration=INT
		public Assignment getDurationAssignment_8() { return cDurationAssignment_8; }

		//INT
		public RuleCall getDurationINTTerminalRuleCall_8_0() { return cDurationINTTerminalRuleCall_8_0; }

		//","
		public Keyword getCommaKeyword_9() { return cCommaKeyword_9; }

		//"line"
		public Keyword getLineKeyword_10() { return cLineKeyword_10; }

		//"="
		public Keyword getEqualsSignKeyword_11() { return cEqualsSignKeyword_11; }

		//line=INT
		public Assignment getLineAssignment_12() { return cLineAssignment_12; }

		//INT
		public RuleCall getLineINTTerminalRuleCall_12_0() { return cLineINTTerminalRuleCall_12_0; }

		//","
		public Keyword getCommaKeyword_13() { return cCommaKeyword_13; }

		//"col"
		public Keyword getColKeyword_14() { return cColKeyword_14; }

		//"="
		public Keyword getEqualsSignKeyword_15() { return cEqualsSignKeyword_15; }

		//col=INT
		public Assignment getColAssignment_16() { return cColAssignment_16; }

		//INT
		public RuleCall getColINTTerminalRuleCall_16_0() { return cColINTTerminalRuleCall_16_0; }

		//")"
		public Keyword getRightParenthesisKeyword_17() { return cRightParenthesisKeyword_17; }
	}

	public class SetTurnAngleCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetTurnAngleCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetTurnAngleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAngleKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAngleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAngleDOUBLETerminalRuleCall_4_0 = (RuleCall)cAngleAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SetTurnAngleCmd returns robot::SetTurnAngleCmd:
		//	"setTurnAngle" "(" "angle" "=" angle=DOUBLE ")";
		public ParserRule getRule() { return rule; }

		//"setTurnAngle" "(" "angle" "=" angle=DOUBLE ")"
		public Group getGroup() { return cGroup; }

		//"setTurnAngle"
		public Keyword getSetTurnAngleKeyword_0() { return cSetTurnAngleKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"angle"
		public Keyword getAngleKeyword_2() { return cAngleKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//angle=DOUBLE
		public Assignment getAngleAssignment_4() { return cAngleAssignment_4; }

		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_4_0() { return cAngleDOUBLETerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class StopEngineCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StopEngineCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStopEngineCmdAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStopEngineKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//StopEngineCmd returns robot::StopEngineCmd:
		//	{robot::StopEngineCmd} "stopEngine";
		public ParserRule getRule() { return rule; }

		//{robot::StopEngineCmd} "stopEngine"
		public Group getGroup() { return cGroup; }

		//{robot::StopEngineCmd}
		public Action getStopEngineCmdAction_0() { return cStopEngineCmdAction_0; }

		//"stopEngine"
		public Keyword getStopEngineKeyword_1() { return cStopEngineKeyword_1; }
	}

	public class StopProgramCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StopProgramCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStopProgramCmdAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStopProgramKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//StopProgramCmd returns robot::StopProgramCmd:
		//	{robot::StopProgramCmd} "stopProgram";
		public ParserRule getRule() { return rule; }

		//{robot::StopProgramCmd} "stopProgram"
		public Group getGroup() { return cGroup; }

		//{robot::StopProgramCmd}
		public Action getStopProgramCmdAction_0() { return cStopProgramCmdAction_0; }

		//"stopProgram"
		public Keyword getStopProgramKeyword_1() { return cStopProgramKeyword_1; }
	}

	public class TurnCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TurnCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTurnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPowerKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPowerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPowerDOUBLETerminalRuleCall_4_0 = (RuleCall)cPowerAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cAngleKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cAngleAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cAngleDOUBLETerminalRuleCall_8_0 = (RuleCall)cAngleAssignment_8.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//TurnCmd returns robot::TurnCmd:
		//	"turn" "(" "power" "=" power=DOUBLE "," "angle" "=" angle=DOUBLE ")";
		public ParserRule getRule() { return rule; }

		//"turn" "(" "power" "=" power=DOUBLE "," "angle" "=" angle=DOUBLE ")"
		public Group getGroup() { return cGroup; }

		//"turn"
		public Keyword getTurnKeyword_0() { return cTurnKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"power"
		public Keyword getPowerKeyword_2() { return cPowerKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//power=DOUBLE
		public Assignment getPowerAssignment_4() { return cPowerAssignment_4; }

		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_4_0() { return cPowerDOUBLETerminalRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//"angle"
		public Keyword getAngleKeyword_6() { return cAngleKeyword_6; }

		//"="
		public Keyword getEqualsSignKeyword_7() { return cEqualsSignKeyword_7; }

		//angle=DOUBLE
		public Assignment getAngleAssignment_8() { return cAngleAssignment_8; }

		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_8_0() { return cAngleDOUBLETerminalRuleCall_8_0; }

		//")"
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }
	}

	public class ObstacleCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObstacleCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObstacleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cDistanceKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDistanceAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDistanceDOUBLETerminalRuleCall_4_0 = (RuleCall)cDistanceAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ObstacleCmd returns robot::ObstacleCmd:
		//	"obstacle" "(" "distance" "=" distance=DOUBLE ")";
		public ParserRule getRule() { return rule; }

		//"obstacle" "(" "distance" "=" distance=DOUBLE ")"
		public Group getGroup() { return cGroup; }

		//"obstacle"
		public Keyword getObstacleKeyword_0() { return cObstacleKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//"distance"
		public Keyword getDistanceKeyword_2() { return cDistanceKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//distance=DOUBLE
		public Assignment getDistanceAssignment_4() { return cDistanceAssignment_4; }

		//DOUBLE
		public RuleCall getDistanceDOUBLETerminalRuleCall_4_0() { return cDistanceDOUBLETerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class BOOLEAN_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN_LITERAL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLEAN_LITERAL returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	
	
	private ProgramUnitElements pProgramUnit;
	private ExpressionElements pExpression;
	private BoolExpElements pBoolExp;
	private WhileLoopElements pWhileLoop;
	private NegExpElements pNegExp;
	private AndExpElements pAndExp;
	private IfBlockElements pIfBlock;
	private CommandElements pCommand;
	private BipElements pBip;
	private HasTurnedCmdElements pHasTurnedCmd;
	private MoveCmdElements pMoveCmd;
	private PrintCmdElements pPrintCmd;
	private SetTurnAngleCmdElements pSetTurnAngleCmd;
	private StopEngineCmdElements pStopEngineCmd;
	private StopProgramCmdElements pStopProgramCmd;
	private TurnCmdElements pTurnCmd;
	private ObstacleCmdElements pObstacleCmd;
	private BOOLEAN_LITERALElements pBOOLEAN_LITERAL;
	private TerminalRule tSTRING;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tDIGIT;
	private TerminalRule tDOUBLE;
	private TerminalRule tINT;
	
	private final Grammar grammar;

	@Inject
	public LegoGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("insa.Lego".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//ProgramUnit returns robot::ProgramUnit:
	//	block+=Expression*;
	public ProgramUnitElements getProgramUnitAccess() {
		return (pProgramUnit != null) ? pProgramUnit : (pProgramUnit = new ProgramUnitElements());
	}
	
	public ParserRule getProgramUnitRule() {
		return getProgramUnitAccess().getRule();
	}

	//Expression returns FlotCtrl::Expression:
	//	WhileLoop | NegExp | AndExp | IfBlock | Command;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//BoolExp returns FlotCtrl::BoolExp:
	//	NegExp | AndExp | HasTurnedCmd | ObstacleCmd;
	public BoolExpElements getBoolExpAccess() {
		return (pBoolExp != null) ? pBoolExp : (pBoolExp = new BoolExpElements());
	}
	
	public ParserRule getBoolExpRule() {
		return getBoolExpAccess().getRule();
	}

	//WhileLoop returns FlotCtrl::WhileLoop:
	//	"while" loopCond=BoolExp "do" block+=Expression* "end";
	public WhileLoopElements getWhileLoopAccess() {
		return (pWhileLoop != null) ? pWhileLoop : (pWhileLoop = new WhileLoopElements());
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}

	//NegExp returns FlotCtrl::NegExp:
	//	"not" exp=BoolExp;
	public NegExpElements getNegExpAccess() {
		return (pNegExp != null) ? pNegExp : (pNegExp = new NegExpElements());
	}
	
	public ParserRule getNegExpRule() {
		return getNegExpAccess().getRule();
	}

	//AndExp returns FlotCtrl::AndExp:
	//	"and" leftExp=BoolExp rightExp=BoolExp;
	public AndExpElements getAndExpAccess() {
		return (pAndExp != null) ? pAndExp : (pAndExp = new AndExpElements());
	}
	
	public ParserRule getAndExpRule() {
		return getAndExpAccess().getRule();
	}

	//IfBlock returns FlotCtrl::IfBlock:
	//	"if" condition=BoolExp "then" thenBlock+=Expression* ("else" elseBlock+=Expression*)? "end";
	public IfBlockElements getIfBlockAccess() {
		return (pIfBlock != null) ? pIfBlock : (pIfBlock = new IfBlockElements());
	}
	
	public ParserRule getIfBlockRule() {
		return getIfBlockAccess().getRule();
	}

	//Command returns robot::Command:
	//	MoveCmd | PrintCmd | SetTurnAngleCmd | StopEngineCmd | StopProgramCmd | TurnCmd | HasTurnedCmd | ObstacleCmd;
	public CommandElements getCommandAccess() {
		return (pCommand != null) ? pCommand : (pCommand = new CommandElements());
	}
	
	public ParserRule getCommandRule() {
		return getCommandAccess().getRule();
	}

	//Bip returns robot::Bip:
	//	"bip" "(" "duration" "=" duration=INT "," "power" "=" power=DOUBLE "," "repeat" "=" repet=BOOLEAN_LITERAL ")";
	public BipElements getBipAccess() {
		return (pBip != null) ? pBip : (pBip = new BipElements());
	}
	
	public ParserRule getBipRule() {
		return getBipAccess().getRule();
	}

	//HasTurnedCmd returns robot::HasTurnedCmd:
	//	"hasTurned" "(" "angle" "=" angle=DOUBLE ")";
	public HasTurnedCmdElements getHasTurnedCmdAccess() {
		return (pHasTurnedCmd != null) ? pHasTurnedCmd : (pHasTurnedCmd = new HasTurnedCmdElements());
	}
	
	public ParserRule getHasTurnedCmdRule() {
		return getHasTurnedCmdAccess().getRule();
	}

	//MoveCmd returns robot::MoveCmd:
	//	"move" "(" "power" "=" power=DOUBLE ")";
	public MoveCmdElements getMoveCmdAccess() {
		return (pMoveCmd != null) ? pMoveCmd : (pMoveCmd = new MoveCmdElements());
	}
	
	public ParserRule getMoveCmdRule() {
		return getMoveCmdAccess().getRule();
	}

	//PrintCmd returns robot::PrintCmd:
	//	"display" "(" "msg" "=" msg=STRING "," "duration" "=" duration=INT "," "line" "=" line=INT "," "col" "=" col=INT ")";
	public PrintCmdElements getPrintCmdAccess() {
		return (pPrintCmd != null) ? pPrintCmd : (pPrintCmd = new PrintCmdElements());
	}
	
	public ParserRule getPrintCmdRule() {
		return getPrintCmdAccess().getRule();
	}

	//SetTurnAngleCmd returns robot::SetTurnAngleCmd:
	//	"setTurnAngle" "(" "angle" "=" angle=DOUBLE ")";
	public SetTurnAngleCmdElements getSetTurnAngleCmdAccess() {
		return (pSetTurnAngleCmd != null) ? pSetTurnAngleCmd : (pSetTurnAngleCmd = new SetTurnAngleCmdElements());
	}
	
	public ParserRule getSetTurnAngleCmdRule() {
		return getSetTurnAngleCmdAccess().getRule();
	}

	//StopEngineCmd returns robot::StopEngineCmd:
	//	{robot::StopEngineCmd} "stopEngine";
	public StopEngineCmdElements getStopEngineCmdAccess() {
		return (pStopEngineCmd != null) ? pStopEngineCmd : (pStopEngineCmd = new StopEngineCmdElements());
	}
	
	public ParserRule getStopEngineCmdRule() {
		return getStopEngineCmdAccess().getRule();
	}

	//StopProgramCmd returns robot::StopProgramCmd:
	//	{robot::StopProgramCmd} "stopProgram";
	public StopProgramCmdElements getStopProgramCmdAccess() {
		return (pStopProgramCmd != null) ? pStopProgramCmd : (pStopProgramCmd = new StopProgramCmdElements());
	}
	
	public ParserRule getStopProgramCmdRule() {
		return getStopProgramCmdAccess().getRule();
	}

	//TurnCmd returns robot::TurnCmd:
	//	"turn" "(" "power" "=" power=DOUBLE "," "angle" "=" angle=DOUBLE ")";
	public TurnCmdElements getTurnCmdAccess() {
		return (pTurnCmd != null) ? pTurnCmd : (pTurnCmd = new TurnCmdElements());
	}
	
	public ParserRule getTurnCmdRule() {
		return getTurnCmdAccess().getRule();
	}

	//ObstacleCmd returns robot::ObstacleCmd:
	//	"obstacle" "(" "distance" "=" distance=DOUBLE ")";
	public ObstacleCmdElements getObstacleCmdAccess() {
		return (pObstacleCmd != null) ? pObstacleCmd : (pObstacleCmd = new ObstacleCmdElements());
	}
	
	public ParserRule getObstacleCmdRule() {
		return getObstacleCmdAccess().getRule();
	}

	//BOOLEAN_LITERAL returns ecore::EBoolean:
	//	"true" | "false";
	public BOOLEAN_LITERALElements getBOOLEAN_LITERALAccess() {
		return (pBOOLEAN_LITERAL != null) ? pBOOLEAN_LITERAL : (pBOOLEAN_LITERAL = new BOOLEAN_LITERALElements());
	}
	
	public ParserRule getBOOLEAN_LITERALRule() {
		return getBOOLEAN_LITERALAccess().getRule();
	}

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return (tDIGIT != null) ? tDIGIT : (tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT"));
	} 

	//terminal DOUBLE returns ecore::EDouble:
	//	INT ("." DIGIT*);
	public TerminalRule getDOUBLERule() {
		return (tDOUBLE != null) ? tDOUBLE : (tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOUBLE"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0" | "1".."9" DIGIT*;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 
}
